## 图

#### 无向图

<img src="./img/无向图.jpg" alt="无向图" style="zoom:27%;" />

```
A: C,D
B: C
C: A,B,D
D: A,C
```

> 把题中所给的图结构先转换成自己熟悉的结构，这样在做题的时候就会很熟悉，还会很稳

1. **性质**
   * 入度等于出度

2. **结构**

   ```java
   public class Graph {
       public HashMap<Integer, Node> nodes;
       public HashSet<Edge> edges;
   
       public Graph() {
           nodes = new HashMap<>();
           edges = new HashSet<>();
       }
   }
   
   public class Edge {
       //权值
       public int weight;
       public Node from;
       public Node to;
   
       public Edge(int weight, Node from, Node to) {
           this.weight = weight;
           this.from = from;
           this.to = to;
       }
   }
   
   public class Node {
       //节点的值
       public int value;
       //入度
       public int in;
       //出度
       public int out;
       //从该节点发散出去的点集合，即从该点指向的别的点
       public ArrayList<Node> nexts;
       //哪些边属于自己，即哪些边的屁股对着自己
       public ArrayList<Edge> edges;
   
       public Node(int value) {
           this.value = value;
           in = 0;
           out = 0;
           nexts = new ArrayList<>();
           edges = new ArrayList<>();
       }
   }
   ```

   >    在图中，nodes对应的哈希表结构可以换成数组，因为有时候给定的城市编号都不会太大，下标直接对应node，数组的直接寻址会更快一点

3. **构造图结构**

   ```java
       public static Graph createGraph(int[][] matrix) {
           Graph graph = new Graph();
           for (int i = 0; i < matrix.length; i++) {
               Integer from = matrix[i][0];
               Integer to = matrix[i][1];
               Integer weight = matrix[i][2];
               if (!graph.nodes.containsKey(from)) {
                   graph.nodes.put(from, new Node(from));
               }
               if (!graph.nodes.containsKey(to)) {
                   graph.nodes.put(to, new Node(to));
               }
               Node fromNode = graph.nodes.get(from);
               Node toNode = graph.nodes.get(to);
               fromNode.out++;
               toNode.in++;
               Edge edge = new Edge(weight, fromNode, toNode);
               fromNode.edges.add(edge);
               fromNode.nexts.add(toNode);
               graph.edges.add(edge);
           }
           return graph;
       }
   ```

* **宽度优先遍历** （一队一set）

  <img src="./img/宽度遍历.jpg" alt="宽度优先遍历" style="zoom:25%;" />  ```ACBDE || ABCDE || ADCBE 都是宽度优先遍历```

  1. **流程**

     定义一个队列和一个`hashset` ，初始化时A入队入set。

     出队，元素为A，对A的`nexts`遍历，`nexts`中有三个节点B C D，查看B是否在set中，不在，那么入队入set。查看C是否在set中，不在，入队入set，D同理，此时队里是D C B，set 里是 A B C D

     此next遍历结束，队伍不空，便继续出队B，发现B的`nexts`中的A在set中已经存在了，所以A就不set入队了

     > 这里就可以看出来set的作用，set使得这个图可以遍历完，不会进入循环状态

  2. **代码实现**

     ```java
     	public static void BFS(Node node) {
             if (node == null) {
                 return;
             }
             LinkedList<Node> queue = new LinkedList<>();
             HashSet<Node> set = new HashSet<>();
             queue.add(node);
             set.add(node);
             while (!queue.isEmpty()) {
                 node = queue.poll();
                 System.out.println(node.value);
                 for (Node n : node.nexts) {
                     if(!set.contains(n)){
                         queue.add(n);
                         set.add(n);
                     }
                 }
             }
         }
     ```

* **深度优先遍历**（一栈一set）

  <img src="./img/深度遍历.jpg" alt="深度遍历" style="zoom:20%;" /> ```A -> B -> C -> D -> E```

  1. **流程**

     初始化：A入栈入set

     ​	出栈节点为A，处理A的`nexts`，处理到一个节点B发现它不在set里面，说明它没被遍历到过，那么就从B开始往下面找到底，但是这时A的其他`nexts`还没遍历完，所以再把A压回栈，然后B节点入栈入set，处理B。B的`nexts`A在set里面有，所以B结束，栈里还有A。

     ​	A出栈，重新处理`nexts`，B在set里有了，然后搞C，再A入栈，然后C入栈入set，处理C...

     > 因为入set的时候就意味着这个节点已经处理完了，所以可以处理这个节点了，输出值之类的或者其他操作

  2. **代码实现**

     ```java
     	public static void dfs(Node node) {
             if (node == null) {
                 return;
             }
             Stack<Node> stack = new Stack<>();
             HashSet<Node> set = new HashSet<>();
             stack.push(node);
             set.add(node);
             System.out.println(node.value);
             while (!stack.empty()) {
                 node = stack.pop();
                 for (Node next : node.nexts) {
                     if (!set.contains(next)) {
                         set.add(next);
                         System.out.println(next.value);
                         stack.push(node);
                         stack.push(next);
                         break;//*
                     }
                 }
             }
         }
     ```

     > 注意在for循环里面，如果找到了没有遍历过的节点（即set中不存在的节点），就要把之前stack中pop的节点重新放回去，然后！！`break`跳出对其他next节点的检查，不要忘记`break`！

* **拓扑排序**

  1. **问题描述**

     比如编译时需要的依赖包：A依赖B，C，D，B依赖C，D，E，那么图的结构如下

     <img src="./img/拓扑排序.jpg" alt="拓扑排序" style="zoom:15%;" />

     * 找到入度为0的节点，然后删除它以及它的全部影响。
     * 再找到入度为0的节点，然后删除它以及它的全部影响。
     * 直到图中没有节点

  2. **例题**

     <img src="./img/拓扑1.jpg" alt="拓扑1" style="zoom:23%;" />

  3. **流程**

     * 建立一个key为node，value为in（入度）的map，以及入度为0的node队列

     * 遍历给的图中的所有节点，将信息写入map中，并将入度为0的点入队。

     * 出队一个节点（就相当于这个节点已经处理完了），然后删除这个节点的影响

     * 遍历这个出队节点的`nexts`，把它们在map中的对应入度--

     * 判断减完之后这个节点的入度是否为0，是的话把它入队

     * 循环，直到队列为空

       > 注：新建的节点对应入度的map，是为了保留原来图不变，不能直接在node的节点上更改数据

  4. **代码实现**

     ```java
     	public static List<Node> sortedTopology(Graph graph) {
             LinkedList<Node> zeroInNodes = new LinkedList<>();
             HashMap<Node, Integer> map = new HashMap<>();
             for (Node node : graph.nodes.values()) {
                 map.put(node, node.in);
                 if (node.in == 0) {
                     zeroInNodes.add(node);
                 }
             }
             ArrayList<Node> res = new ArrayList<>();
             while (!zeroInNodes.isEmpty()) {
                 Node node = zeroInNodes.poll();
                 res.add(node);
                 for (Node n : node.nexts) {
                     int in = map.get(n) - 1;
                     map.put(n, in);
                     if (in == 0) {
                         zeroInNodes.add(n);
                     }
                 }
             }
             return res;
         }
     ```

     > 将`hashMap`中key对应的所有value放到一个集合里面：```map.values()```